---
title: "[CPlusPlus_Study]C++로의 전환"
layout: post
date: 2018-05-10 00:44
image: /assets/images/markdown.jpg
headerImage: false
tag:
- CPlusPlus Programming
- Coding
- CPlusPlus
  star: false
  category: blog
  author: john Ko
  description: Coding
---

## Title : Part01-02 C++로의 전환

### Chapter 04 C언어 기반의 C++ 2 

**클레스의 완성**

**Chapter 04-01 정보은닉**

* 외부 클래스에서 접근하는 것을 막는 것을 정보은닉이라고 합니다.
* 클래스의 정의와 관련이 있는 정보들을 잘 묶어놓은것을 캡슐화라고 한다.
* 캡슐화라는 것은 클래스별로 독립성 유지하면서 변경 혹은 확장 대해서 대응 가능한 클래스 수준을 높이는것을 말합니다.
* 멤버 변수의 외부 접근을 허용하면 , 잘 못된 값이 저장되는 문제가 발생할 수 있다 따라서 멤버 변수의 외부접근을 막게 되는데 이를 정보은닉이라고 한다.
* 클래스의 캑체도 다른 객체의 멤버가 될수 있다.
* 클래스의 멤버 변수를 private으로 선언 하고 해당 변수에 접근하는 함수를 별도로 정의해서 안전한 형태로 멤버변수의 접근을 유도하는 것을 바로 '정보은닉'이라고 한다. 엑세스 함수(정보은닉을 위한 함수)
* 함수만 한번 잘 정의 되면 잘 못된 접근을 원천적으로 차단된다. 하지만 정보은닉을 하지 않는다면 접근할때 주의해야한다.



**멤버함수의 const 선언**

```c++
int GetX()const
int GetY()const
// const 함수 내에서는 동일 클래스에 선언된 멤버변수의 값을 변경하지 못한다.
// const 함수 는 const가 아닌 함수를 호출 하지 못한다.!
// 간접적인 멤버의 변경 가능성까지 차단한다.
    
```



* const로 상수화 된 객체를 대상으로는 const  멤버함수만 호출이 가능하다.



**Chapter 04-02 캡슐화 **

- 캡슐화란 관련 있는 모든 것을 하나의 클래스 안에 묶어 두는것을 말합니다.



**생성자와 소멸자**

- 객체는 생성하고 나서 적절한 값으로 초기화를 해주어야 한다.

- 생성자는 함수의 일종이다.

- 초기화를 위해서 함수 호출이 필요하다.

- 생성자는 객체가 생성될때 자동으로 호출되는 함수이다.

- 소멸자는 객체가 소멸될때 자동으로 호출되는 함수이다.

- 소멸자가 필요한 이유는 메모리 반환을 위해 사용한다.

  ```c++
  class SimpleClass
  {
   private:
      int num;
   public :
      SimpleClass(int n)
      {
          num=n;
      }
      /*
      1. 클래스의 이름과 동일한 이름의 함수이면서
         반환형이 선언되지 않았고 실제로 반환하지 
         않는 함수를 가리켜 생성자라고한다.
      
      2. 생성자도 함수의 일종이므로 오버로딩이 가능
         하고 디폴트 값 설정이 가능하다.
      
      3. 생성자를 정의하지 않더라도 디폴트 생성자가
         만들어져 호출한다.
      
      4. 생성자도 함수의 일종이므로 오버로딩이 가능하고
         디폴트 값 설정이 가능하다.
      
      5. 프로그래머가 생성자를 정의하면 컴파일러는
         생성자를 삽입하지 않습니다.
         
      6. 생성자는 오버로딩이 가능하다.
      7. 생성자도 디폴트 값이 설정이 가능하다.
      */
  }
  
  //생성방법
  /*
  
  SimpleClass sc1();  X 함수의 원형선언과 비슷해서 안됨
  SimpleClass sc1;    O
  SimpleClass * ptr1=new SimpleClass ;  O
  SimpleClass * ptr1=new SimpleClass ;  O
  
  */
  ```



* 객체안에 객체가 있을경우 이니셜라이저 를 이용하여 생성자 호출한다.

* 멤버 이니셜라이저는 함수의 선언부가 아닌 정의 부에 명시한다.

  1단계 : 메모리 공간의 할당

  2단계 : 이니셜라이저를 이용한 멤버변수(객체)의 초기화

  3단계 : 생성자의 몸체 부분을 실행

* 이니셜라이저를 통해서 멤버 변수의 초기화도 가능하며 초기화하는 경우 선어과 동시에 초기화되는 형태로 바이너리가 구성된다. 즉 다음의 형태로 멤버 변수가 선언과 동시에 초기화 된다.

* const 로 선언된 멤버 변수도 초기화가 가능하다. 선언과 동시에 초기화된다.

* 이니셜라이저의 초기화는 선언과 동시에 초기화 되는 형태이므로 참조자의 초기화도 가능하다.

* 생성자가 private인 경우 클래스 외부에서는 이 생성자의 호출을 통해서 객체 생성이 불가능하다.

* 소멸자는 오버로딩이 불가능 하다.

* 소멸자가 정의 하지 않으면 디폴트 소멸자가 삽입된다.

* 동적할당한 데이터를 소멸자에서 delete 시킨다.

  ## Chpter 05 복사 생성자(Copy Constructor)

  **05-01 "복사 생성자"와의 첫만남**

  복사 생성자의 이유

  객체간의 대입 연산자의 과정의 일은 쉽개 결정할수 없는 일이다. 클래스 정의 할때 대입연산 과정에서 일어나는 일은 프로그래머가 결정해야한다.

  

  ```c++
  abc obj1=obj2;
  abc obj3;
  abc obj4;
  obj3=obj4;
  //객체를 생성하면서 초기화와 생성된 피객체간의 대입연산자의 방식은 다르다.
  ```

  복사생성자는 객체를 초기화 후 할당할때 생긴다.

새로운 객체를 생성하되 기존의 객체로 초기화 할때 대입연산을 할때 복사생성자가 호출된다.

```c++
int num=20 ; 
int num(20);
int &ref=num;
int &ref(num);
sosimple sim2=sim1;
sosimple sim2(sim1); 
객체를 대입연산을 하면 객체를 인자로 받는 생성자를 호출 한다.
```

* 복사 생성자는 정의가 되어 있지 않으면 자동으로 삽입됩니다.
* 디폴트 복사 생성자는 값을 복사한다
* 복사 생성자의 인자의 const를 선언해주어야 한다. (대입 객체의 값이 변경되지 않게 하기 위해)



**explicit**

* 묵시적 형 변환을 막는다.

  ```c++
  sosimple sim2=sim1;//묵시적 형변환 explicit가 있을 경우 컴파일이 안됨
  sosimple sim2(sim1);//명시적 형변환
  ```

  